apply plugin: 'com.android.library'
apply from: '../configuration.gradle'
apply plugin: 'com.kezong.fat-aar'

import org.gradle.internal.os.OperatingSystem

def ext = project.ext
def config = ext.configuration
def project_publication = ext.publicationProperties(project.name)

def fatAar = false

tasks.withType(Javadoc) {
    options.encoding = 'UTF-8'
}

android {
    compileSdkVersion 27

    compileOptions {
        sourceCompatibility config.SOURCE_COMPATIBILITY
        targetCompatibility config.TARGET_COMPATIBILITY
    }

    lintOptions {
        abortOnError false
    }

    // To let the libs be included in other projects
    // Uncomment if you want to rebuild libsodiumjni
    //    externalNativeBuild {
    //        ndkBuild {
    //            path "jni/Android.mk"
    //        }
    //    }

    defaultConfig {
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        minSdkVersion 21
        targetSdkVersion 27
        versionCode 1
        versionName project_publication.VERSION
    }

    buildTypes {
        release {
            minifyEnabled false
        }
    }
    
    testOptions {
        unitTests.all {
            useJUnitPlatform()
        }
    }
}

[
        [input_arch: 'arm', output_arch: 'android-armv6', ndk_platform: 'android-16'],
        [input_arch: 'armv7-a', output_arch: 'android-armv7-a', ndk_platform: 'android-16'],
        [input_arch: 'armv8-a', output_arch: 'android-armv8-a', ndk_platform: 'android-21'],
        [input_arch: 'x86', output_arch: 'android-i686', ndk_platform: 'android-16'],
        [input_arch: 'x86_64', output_arch: 'android-westmere', ndk_platform: 'android-21'],
].each { opts ->

    def taskname = "compileNative_${opts['output_arch']}"

    task(taskname) {
        inputs.dir fileTree(dir: 'libsodium/src', exclude: ['libsodium/**/.libs', 'libsodium/*.la', 'libsodium/**/*.lo', 'libsodium/**/*.o', 'libsodium/**/*.Plo', '**/Makefile', '**/Makefile.in', '**/.deps/*', '**/.libs/*'])
        outputs.dir("libsodium/libsodium-${opts['output_arch']}")
        doFirst {
            exec {
                workingDir 'libsodium'
                commandLine './autogen.sh'
            }
            exec {
                workingDir 'libsodium'
                environment 'LIBSODIUM_FULL_BUILD', 'true'
                executable "dist-build/android-${opts['input_arch']}.sh"
                environment 'CONFIG_SITE', ''
            }
        }
    }

    // Uncomment if you want to rebuild libsodiumjni
    // gradle.projectsEvaluated {
    //    externalNativeBuildDebug.dependsOn taskname
    //    externalNativeBuildRelease.dependsOn taskname
    // }
}

//gradle.buildFinished { BuildResult result ->
//    if (result.failure == null) {
//        buildNativeJar.execute()
//    }
//}

apply from: '../publication_android.gradle'

task unzipAAR(type: Copy) {
    def aar = file("${buildDir}/outputs/aar/" + project_publication.ARTIFACT_ID + "-release.aar")
    from zipTree(aar)
    into "${buildDir}/outputs/aar/unzip"
}

task copyNativeLib(type: Copy, dependsOn: 'deleteNativeLib') {
    from "${buildDir}/libs/sodiumjni/shared/", "${buildDir}/intermediates/library_and_local_jars_jni/release/"
    into 'native-lib/lib'
}

task deleteNativeLib(type: Delete) {
    delete 'native-lib'
}

task libraryJar(type: Zip, dependsOn: [/*'copyNativeLib',*/ 'unzipAAR']) {
    destinationDir file("$buildDir/libs")
    baseName project_publication.ARTIFACT_ID
    extension 'jar'
    from zipTree(file("${buildDir}/outputs/aar/unzip/classes.jar")), "native-lib"
}

task deleteNativeJar(type: Delete) {
    delete "${buildDir}/libs/native-jar"
}

task buildNativeJar(type: Zip, dependsOn: ['copyNativeLib', 'deleteNativeJar']) {
    destinationDir file("$buildDir/libs/native-jar")
    baseName 'libsodium'
    version ''
    extension 'jar'
    from('native-lib/lib') {
        include '**/*.so*', '*.dylib', '*.dll', '*.so'
    }
    into 'lib'
    doLast {
        copy {
            from "$buildDir/libs/native-jar"
            into "lib"
        }
    }
}

apply plugin: "c"

model {
    flavors {
        host
        // Also compile the native library for the host OS to allow running tests which access the library on the host OS.
    }
    repositories {
        libs(PrebuiltLibraries) {
            jdk {
                headers.srcDir "${System.getenv("JAVA_HOME")}/include"
                headers.srcDir "${System.getenv("JAVA_HOME")}/include/linux"
                // this seems to be host OS dependent, but should be host OS independent
            }
            sodium {
                headers.srcDir "${projectDir}/libsodium/libsodium-host/include"
                binaries.withType(StaticLibraryBinary) { binary ->
                    staticLibraryFile = file("${projectDir}/libsodium/libsodium-host/lib/libsodium.a")
                }
            }
        }
    }
    components {
        sodiumjni(NativeLibrarySpec) {
            sources {
                c {
                    source {
                        srcDir "${projectDir}/jni"
                        include "sodium_wrap.c"
                    }
                    lib library: 'jdk', linkage: 'api'
                    lib library: 'sodium', linkage: 'static'
                }
                binaries.all {
                    if (OperatingSystem.current().isLinux()) {
                        //flag not on macos clang
                        linker.args "-Wl,-Bsymbolic"
                        // to work around error "shared library text segment is not shareable"
                    }
                }
            }
        }
    }
}

task('generateSWIGsource') {
    inputs.dir fileTree(dir: "${projectDir}/jni")
    outputs.dir("${projectDir}/src/main/java/com/bitmark/cryptography/crypto/sodium")
    outputs.file "${projectDir}/jni/sodium_wrap.c"
    doFirst {
        exec {
            workingDir "${projectDir}/jni"
            commandLine 'swig', '-java', '-package', 'com.bitmark.cryptography.crypto.sodium', '-outdir', '../src/main/java/com/bitmark/cryptography/crypto/sodium', 'sodium.i'
        }
    }
}

// Uncomment if you want to re-generate jni file
//gradle.projectsEvaluated {
//    generateJsonModelDebug.dependsOn 'generateSWIGsource'
//    generateJsonModelRelease.dependsOn 'generateSWIGsource'
//}

artifacts {
    archives javadocJar, sourcesJar, libraryJar
}

ext.additionalArtifact = libraryJar

dependencies {
    
    if (fatAar) {
        embed fileTree(include: '*.jar', dir: 'lib')
        embed deps.bouncycastle

        compileOnly fileTree(include: '*.jar', dir: 'lib')
        compileOnly deps.bouncycastle
    } else {
        implementation fileTree(include: '*.jar', dir: 'lib')
        implementation deps.bouncycastle
    }
    
    testImplementation deps.junit_jupiter.api
    testImplementation deps.junit_jupiter.params
    testImplementation deps.junit_jupiter.engine

}

allprojects {
    tasks.withType(Javadoc) {
        options.addStringOption('Xdoclint:none', '-quiet')
    }
}
